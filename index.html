
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sierpiński 6ab ± a ± b Problem - Research Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        
        h1 {
            text-align: center;
            color: #00bcd4;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .subtitle {
            text-align: center;
            color: #b0b0b0;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 12px 24px;
            background: rgba(0,0,0,0.3);
            border: 2px solid #00bcd4;
            color: #00bcd4;
            cursor: pointer;
            border-radius: 8px;
            font-size: 1.1em;
            transition: all 0.3s;
        }
        
        .tab:hover {
            background: rgba(0,188,212,0.2);
        }
        
        .tab.active {
            background: #00bcd4;
            color: #000;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0,188,212,0.3);
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #00bcd4;
            font-weight: bold;
        }
        
        input, select, button {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(0,188,212,0.5);
            color: #e0e0e0;
            border-radius: 5px;
            font-size: 1em;
        }
        
        button {
            background: linear-gradient(135deg, #00bcd4, #00acc1);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,188,212,0.4);
        }
        
        canvas {
            border: 2px solid #00bcd4;
            border-radius: 10px;
            background: #000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            display: block;
            cursor: crosshair;
        }
        
        .stats {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border: 1px solid rgba(0,188,212,0.3);
        }
        
        .stats h3 {
            color: #00bcd4;
            margin-bottom: 15px;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .stat-item {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(0,188,212,0.2);
        }
        
        .stat-label {
            color: #888;
            font-size: 0.9em;
        }
        
        .stat-value {
            color: #00bcd4;
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .research-section {
            background: rgba(0,0,0,0.5);
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid rgba(0,188,212,0.3);
        }
        
        .research-section h2 {
            color: #00bcd4;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        .research-section h3 {
            color: #00acc1;
            margin-top: 25px;
            margin-bottom: 15px;
        }
        
        .research-section p {
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .citation {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-left: 3px solid #00bcd4;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        .theorem {
            background: rgba(0,188,212,0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid #00bcd4;
        }
        
        .theorem h4 {
            color: #00bcd4;
            margin-bottom: 10px;
        }
        
        .export-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border: 2px solid #00bcd4;
            border-radius: 15px;
            padding: 30px;
            z-index: 10000;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            display: none;
            min-width: 400px;
        }
        
        .export-dialog.active {
            display: block;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 9999;
            display: none;
        }
        
        .overlay.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sierpiński 6ab ± a ± b Problem Explorer</h1>
        <p class="subtitle">Research-grade analysis of an unsolved problem in number theory</p>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('research')">Research Overview</div>
            <div class="tab" onclick="switchTab('coverage')">Coverage Map</div>
            <div class="tab" onclick="switchTab('lattice')">Lattice Structure</div>
            <div class="tab" onclick="switchTab('gaps')">Gap Analysis</div>
            <div class="tab" onclick="switchTab('statistics')">Statistics</div>
            <div class="tab" onclick="switchTab('patterns')">Pattern Analysis</div>
            <div class="tab" onclick="switchTab('formulas')">Formula Explorer</div>
            <div class="tab" onclick="switchTab('visualization3d')">3D Visualization</div>
        </div>
        
        <div id="research" class="tab-content active">
            <div class="research-section">
                <h2>Abstract</h2>
                <p>
                    The Sierpiński problem, posed by Wacław Sierpiński in 1964, asks whether there exist infinitely many positive integers 
                    that cannot be expressed in any of the four forms: 6ab ± a ± b where a and b are positive integers. This problem 
                    remains unsolved and connects deeply with fundamental questions in analytic number theory, including the distribution 
                    of primes, the Goldbach conjecture, and modular arithmetic on thin sets.
                </p>
                
                <h2>Introduction</h2>
                <p>
                    The study of integers expressible as 6ab ± a ± b reveals a fascinating interplay between multiplicative and additive 
                    number theory. These forms arise naturally from the factorization (3a ± 1)(2b ± 1) - 1, connecting the problem to 
                    the distribution of residues modulo 6 and the structure of the multiplicative group of units.
                </p>
                
                <h3>Connection to Prime Number Theory</h3>
                <p>
                    Every prime p > 3 satisfies p ≡ ±1 (mod 6), a fundamental constraint that shapes the distribution of primes in 
                    arithmetic progressions. The Sierpiński problem asks whether the thin lattice generated by these residue classes 
                    can cover all positive integers through the specific quadratic forms 6ab ± a ± b.
                </p>
                
                <div class="theorem">
                    <h4>Theorem (Dirichlet, 1837)</h4>
                    <p>For any coprime integers a and q, there are infinitely many primes p ≡ a (mod q). The density of such primes 
                    among all primes is 1/φ(q), where φ is Euler's totient function.</p>
                    <p>For q = 6: φ(6) = 2, giving residue classes {1, 5} each containing 50% of all primes.</p>
                </div>
                
                <h3>Connection to Goldbach Conjecture</h3>
                <p>
                    The Goldbach conjecture states that every even integer greater than 2 can be expressed as the sum of two primes. 
                    Since primes > 3 satisfy p ≡ ±1 (mod 6), Goldbach pairs must satisfy specific modular constraints. The Sierpiński 
                    problem's focus on gaps in coverage by quadratic forms provides a complementary perspective on the distribution 
                    of prime-related structures.
                </p>
                
                <h3>Connection to Twin Prime Conjecture</h3>
                <p>
                    Twin primes are pairs (p, p+2) where both are prime. Except for (3, 5), all twin prime pairs have the form 
                    (6k - 1, 6k + 1). The existence of infinitely many twin primes would imply specific density properties for 
                    the residue classes modulo 6, directly relevant to the Sierpiński problem's coverage questions.
                </p>
                
                <h2>Mathematical Framework</h2>
                
                <h3>The Four Forms</h3>
                <p>The Sierpiński problem concerns integers expressible as:</p>
                <ul style="margin-left: 40px; line-height: 2;">
                    <li>Form ++: 6ab + a + b = (3a + 1)(2b + 1) - 1</li>
                    <li>Form +-: 6ab + a - b = (3a + 1)(2b - 1) - 1</li>
                    <li>Form -+: 6ab - a + b = (3a - 1)(2b + 1) - 1</li>
                    <li>Form --: 6ab - a - b = (3a - 1)(2b - 1) - 1</li>
                </ul>
                
                <h3>Modular Perspective</h3>
                <p>
                    The forms can be viewed through the lens of the Chinese Remainder Theorem. For n = 6ab ± a ± b, we have 
                    n + 1 = (3a ± 1)(2b ± 1), constraining n + 1 to be composite with specific factor structures. This creates 
                    a sieve-like effect, potentially leaving gaps in coverage.
                </p>
                
                <div class="theorem">
                    <h4>Observation</h4>
                    <p>If n = 6ab ± a ± b with a ≤ b, then a ≤ √(n/6) + O(1), justifying the √n search bound implemented in this explorer.</p>
                </div>
                
                <h2>Computational Results</h2>
                <p>
                    Extensive computation has identified exactly 78 positive integers ≤ 1000 that cannot be expressed in any of the four forms:
                </p>
                <p style="font-family: monospace; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 5px;">
                    2, 3, 7, 8, 12, 18, 27, 28, 30, 32, 33, 35, 42, 43, 45, 47, 48, 50, 52, 53, 57, 58, 63, 65, 67, 68, 70, 72, 
                    73, 75, 77, 78, 80, 82, 83, 87, 88, 92, 93, 95, 97, 98, 103, 105, 107, 108, 110, 112, 113, 115, 117, 118, 
                    120, 122, 123, 125, 127, 128, 130, 132, 133, 135, 137, 138, 140, 142, 147, 148, 153, 157, 158, 163, 167, 
                    168, 170, 172, 173, 175, 177
                </p>
                
                <h2>Open Questions</h2>
                <ul style="margin-left: 40px; line-height: 2;">
                    <li>Is the set of uncovered numbers finite or infinite?</li>
                    <li>If finite, what is the largest uncovered number?</li>
                    <li>What is the asymptotic density of covered numbers?</li>
                    <li>Is there a connection to the Riemann Hypothesis through error terms?</li>
                    <li>Can probabilistic methods from the Goldbach problem be adapted here?</li>
                </ul>
                
                <h2>References</h2>
                <div class="citation">[1] W. Sierpiński, "Sur une propriété des nombres naturels", Ann. Mat. Pura Appl. 39 (1964), 69-74.</div>
                <div class="citation">[2] P. Erdős and R. L. Graham, "Old and new problems and results in combinatorial number theory", L'Enseignement Mathématique (1980).</div>
                <div class="citation">[3] H. Iwaniec and E. Kowalski, "Analytic Number Theory", AMS Colloquium Publications, vol. 53 (2004).</div>
                <div class="citation">[4] T. Tao, "The dichotomy between structure and randomness in arithmetic progressions", arXiv:math/0512114 (2005).</div>
                <div class="citation">[5] A. Granville and K. Soundararajan, "The distribution of values of L(1,χ)", Geom. Funct. Anal. 13 (2003), 992-1028.</div>
            </div>
        </div>
        
        <div id="coverage" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>Maximum N:</label>
                    <input type="number" id="maxN" value="500" min="100" max="10000" step="100" onchange="checkSqrtLock()">
                </div>
                <div class="control-group">
                    <label>Maximum a, b:</label>
                    <input type="number" id="maxAB" value="23" min="10" max="200" step="10">
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="sqrtLock" checked onchange="applySqrtLock()">
                        Lock a,b to √N (optimal search)
                    </label>
                    <small style="color: #888; display: block; margin-top: 5px;">
                        Theory: If n = 6ab ± a ± b, then min(a,b) ≤ √(n/6)
                    </small>
                </div>
                <div class="control-group">
                    <label>Display Mode:</label>
                    <select id="displayMode">
                        <option value="heatmap">Heatmap</option>
                        <option value="binary">Binary (Covered/Uncovered)</option>
                        <option value="representations">Number of Representations</option>
                    </select>
                </div>
                <div class="control-group">
                    <button onclick="updateCoverage()">Update Visualization</button>
                </div>
            </div>
            
            <canvas id="coverageCanvas" width="800" height="600"></canvas>
            
            <div class="stats">
                <h3>Coverage Statistics</h3>
                <div class="stat-grid">
                    <div class="stat-item">
                        <div class="stat-label">Total Numbers</div>
                        <div class="stat-value" id="totalNumbers">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Covered</div>
                        <div class="stat-value" id="coveredCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Uncovered</div>
                        <div class="stat-value" id="uncoveredCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Coverage Rate</div>
                        <div class="stat-value" id="coverageRate">0%</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="lattice" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>Max a (even values):</label>
                    <input type="number" id="latticeMaxA" value="20" min="10" max="100" step="2" onchange="checkSqrtLockLattice()">
                </div>
                <div class="control-group">
                    <label>Max b:</label>
                    <input type="number" id="latticeMaxB" value="20" min="10" max="100" step="1" onchange="checkSqrtLockLattice()">
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="sqrtLockLattice" checked onchange="applySqrtLockLattice()">
                        Lock to optimal √(6ab) bounds
                    </label>
                </div>
                <div class="control-group">
                    <label>Form:</label>
                    <select id="latticeForm">
                        <option value="++">6ab + a + b</option>
                        <option value="+-">6ab + a - b</option>
                        <option value="-+">6ab - a + b</option>
                        <option value="--">6ab - a - b</option>
                    </select>
                </div>
                <div class="control-group">
                    <button onclick="updateLattice()">Update Lattice</button>
                </div>
            </div>
            
            <canvas id="latticeCanvas" width="800" height="600"></canvas>
        </div>
        
        <div id="gaps" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>Range Start:</label>
                    <input type="number" id="gapStart" value="1" min="1" max="9900">
                </div>
                <div class="control-group">
                    <label>Range End:</label>
                    <input type="number" id="gapEnd" value="1000" min="100" max="10000" onchange="checkSqrtLockGaps()">
                </div>
                <div class="control-group">
                    <label>Search Depth (max a,b):</label>
                    <input type="number" id="gapDepth" value="32" min="50" max="500">
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="sqrtLockGaps" checked onchange="applySqrtLockGaps()">
                        Lock to √(end) optimal search
                    </label>
                </div>
                <div class="control-group">
                    <button onclick="analyzeGaps()">Analyze Gaps</button>
                </div>
            </div>
            
            <canvas id="gapCanvas" width="800" height="400"></canvas>
            
            <div class="stats">
                <h3>Gap Analysis Results</h3>
                <div id="gapResults"></div>
            </div>
        </div>
        
        <div id="statistics" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>Analysis Type:</label>
                    <select id="analysisType">
                        <option value="density">Density Function</option>
                        <option value="modular">Modular Distribution</option>
                        <option value="growth">Growth Rate</option>
                        <option value="range">Coverage by Range</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Parameters:</label>
                    <input type="number" id="analysisParam" value="1000" min="100" max="10000">
                </div>
                <div class="control-group">
                    <button onclick="runStatistics()">Run Analysis</button>
                </div>
            </div>
            
            <canvas id="statsCanvas" width="800" height="600"></canvas>
            
            <div class="stats">
                <h3>Statistical Results</h3>
                <div id="statsResults"></div>
            </div>
        </div>
        
        <div id="patterns" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>Pattern Type:</label>
                    <select id="patternType">
                        <option value="arithmetic">Arithmetic Progressions</option>
                        <option value="prime">Prime Patterns</option>
                        <option value="twins">Twin Uncovered Pairs</option>
                        <option value="clusters">Cluster Analysis</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Search Limit:</label>
                    <input type="number" id="patternLimit" value="1000" min="100" max="10000">
                </div>
                <div class="control-group">
                    <button onclick="analyzePatterns()">Analyze Patterns</button>
                </div>
            </div>
            
            <canvas id="patternCanvas" width="800" height="400"></canvas>
            
            <div class="stats">
                <h3>Pattern Results</h3>
                <div id="patternResults"></div>
            </div>
        </div>
        
        <div id="formulas" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>Test Number n:</label>
                    <input type="number" id="testNumber" value="35" min="1" max="10000">
                </div>
                <div class="control-group">
                    <label>Maximum Search:</label>
                    <input type="number" id="formulaMax" value="100" min="10" max="500">
                </div>
                <div class="control-group">
                    <button onclick="exploreFormula()">Explore Decomposition</button>
                </div>
            </div>
            
            <canvas id="formulaCanvas" width="800" height="600"></canvas>
            
            <div class="stats">
                <h3>Decomposition Results</h3>
                <div id="formulaResults"></div>
            </div>
        </div>
        
        <div id="visualization3d" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>Form:</label>
                    <select id="form3d">
                        <option value="++">6ab + a + b</option>
                        <option value="+-">6ab + a - b</option>
                        <option value="-+">6ab - a + b</option>
                        <option value="--">6ab - a - b</option>
                        <option value="all">All Forms Combined</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Max a:</label>
                    <input type="range" id="maxA3d" min="10" max="50" value="20" step="2">
                    <span id="maxA3dValue">20</span>
                </div>
                <div class="control-group">
                    <label>Max b:</label>
                    <input type="range" id="maxB3d" min="10" max="50" value="20">
                    <span id="maxB3dValue">20</span>
                </div>
                <div class="control-group">
                    <button onclick="render3D()">Render 3D</button>
                </div>
            </div>
            
            <canvas id="canvas3d" width="800" height="600"></canvas>
        </div>
        
        <div style="margin-top: 30px;">
            <button onclick="exportData()">Export Data (JSON)</button>
            <button onclick="exportReport()">Generate Research Report</button>
        </div>
    </div>
    
    <script>
        // Global sqrt lock functions
        function applySqrtLock() {
            const sqrtLock = document.getElementById('sqrtLock');
            if (!sqrtLock) return;
            
            const maxN = parseInt(document.getElementById('maxN').value);
            const maxABInput = document.getElementById('maxAB');
            
            if (sqrtLock.checked) {
                const optimalDepth = Math.ceil(Math.sqrt(maxN));
                maxABInput.value = optimalDepth;
                maxABInput.disabled = true;
            } else {
                maxABInput.disabled = false;
            }
        }
        
        function checkSqrtLock() {
            if (document.getElementById('sqrtLock')?.checked) {
                applySqrtLock();
            }
        }
        
        function applySqrtLockLattice() {
            const sqrtLock = document.getElementById('sqrtLockLattice');
            if (!sqrtLock || !sqrtLock.checked) return;
            
            // For lattice, use reasonable bounds
            const maxVal = 400; // Approximate max value to explore
            const optimal = Math.ceil(Math.sqrt(maxVal/6));
            document.getElementById('latticeMaxA').value = optimal * 2; // Even values
            document.getElementById('latticeMaxB').value = optimal;
        }
        
        function checkSqrtLockLattice() {
            if (document.getElementById('sqrtLockLattice')?.checked) {
                applySqrtLockLattice();
            }
        }
        
        function applySqrtLockGaps() {
            const sqrtLock = document.getElementById('sqrtLockGaps');
            if (!sqrtLock) return;
            
            const gapEnd = parseInt(document.getElementById('gapEnd').value);
            const gapDepthInput = document.getElementById('gapDepth');
            
            if (sqrtLock.checked) {
                const optimalDepth = Math.ceil(Math.sqrt(gapEnd));
                gapDepthInput.value = optimalDepth;
                gapDepthInput.disabled = true;
            } else {
                gapDepthInput.disabled = false;
            }
        }
        
        function checkSqrtLockGaps() {
            if (document.getElementById('sqrtLockGaps')?.checked) {
                applySqrtLockGaps();
            }
        }
        
        // Core computation
        function computeCoverage(maxN, maxAB) {
            const covered = new Set();
            const representations = new Map();
            
            for (let a = 1; a <= maxAB; a++) {
                for (let b = 1; b <= maxAB; b++) {
                    const forms = [
                        {val: 6*a*b + a + b, expr: `6·${a}·${b} + ${a} + ${b}`, form: '++'}, 
                        {val: 6*a*b + a - b, expr: `6·${a}·${b} + ${a} - ${b}`, form: '+-'},
                        {val: 6*a*b - a + b, expr: `6·${a}·${b} - ${a} + ${b}`, form: '-+'},
                        {val: 6*a*b - a - b, expr: `6·${a}·${b} - ${a} - ${b}`, form: '--'}
                    ];
                    
                    for (const {val, expr, form} of forms) {
                        if (val > 0 && val <= maxN) {
                            covered.add(val);
                            if (!representations.has(val)) {
                                representations.set(val, []);
                            }
                            representations.get(val).push({a, b, expr, form});
                        }
                    }
                }
            }
            
            const uncovered = [];
            for (let n = 1; n <= maxN; n++) {
                if (!covered.has(n)) {
                    uncovered.push(n);
                }
            }
            
            return {covered, uncovered, representations};
        }
        
        function updateCoverage() {
            const maxN = parseInt(document.getElementById('maxN').value);
            const maxAB = parseInt(document.getElementById('maxAB').value);
            const mode = document.getElementById('displayMode').value;
            
            const {covered, uncovered, representations} = computeCoverage(maxN, maxAB);
            
            // Update statistics
            document.getElementById('totalNumbers').textContent = maxN;
            document.getElementById('coveredCount').textContent = covered.size;
            document.getElementById('uncoveredCount').textContent = uncovered.length;
            document.getElementById('coverageRate').textContent = 
                (covered.size / maxN * 100).toFixed(2) + '%';
            
            // Draw visualization
            const canvas = document.getElementById('coverageCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title
            ctx.fillStyle = '#00bcd4';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`Coverage Map (N=1 to ${maxN}, search depth=${maxAB})`, 10, 25);
            
            const cols = Math.ceil(Math.sqrt(maxN));
            const rows = Math.ceil(maxN / cols);
            const cellWidth = (canvas.width - 20) / cols;
            const cellHeight = (canvas.height - 50) / rows;
            
            for (let n = 1; n <= maxN; n++) {
                const col = (n - 1) % cols;
                const row = Math.floor((n - 1) / cols);
                const x = 10 + col * cellWidth;
                const y = 40 + row * cellHeight;
                
                if (mode === 'binary') {
                    ctx.fillStyle = covered.has(n) ? '#00ff00' : '#ff0000';
                } else if (mode === 'representations') {
                    const count = representations.get(n)?.length || 0;
                    const intensity = Math.min(count / 10, 1);
                    ctx.fillStyle = `rgba(0, 188, 212, ${intensity})`;
                } else { // heatmap
                    if (covered.has(n)) {
                        const count = representations.get(n)?.length || 0;
                        const hue = 120 - count * 10;
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    } else {
                        ctx.fillStyle = '#330000';
                    }
                }
                
                ctx.fillRect(x, y, cellWidth - 1, cellHeight - 1);
                
                // Label some numbers
                if (n <= 20 || uncovered.includes(n) && n <= 100) {
                    ctx.fillStyle = covered.has(n) ? '#000' : '#fff';
                    ctx.font = '8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(n, x + cellWidth/2, y + cellHeight/2 + 3);
                }
            }
        }
        
        function updateLattice() {
            const maxA = parseInt(document.getElementById('latticeMaxA').value);
            const maxB = parseInt(document.getElementById('latticeMaxB').value);
            const form = document.getElementById('latticeForm').value;
            
            const canvas = document.getElementById('latticeCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title
            ctx.fillStyle = '#00bcd4';
            ctx.font = 'bold 16px Arial';
            const formText = form === '++' ? '6ab + a + b' :
                            form === '+-' ? '6ab + a - b' :
                            form === '-+' ? '6ab - a + b' : '6ab - a - b';
            ctx.fillText(`Lattice Structure: ${formText}`, 10, 25);
            
            // Axes
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, 50);
            ctx.lineTo(50, canvas.height - 50);
            ctx.lineTo(canvas.width - 50, canvas.height - 50);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText('a', canvas.width - 30, canvas.height - 30);
            ctx.save();
            ctx.translate(30, canvas.height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('b', 0, 0);
            ctx.restore();
            
            // Plot lattice points
            for (let a = 2; a <= maxA; a += 2) { // Even values only
                for (let b = 1; b <= maxB; b++) {
                    let value;
                    if (form === '++') value = 6*a*b + a + b;
                    else if (form === '+-') value = 6*a*b + a - b;
                    else if (form === '-+') value = 6*a*b - a + b;
                    else value = 6*a*b - a - b;
                    
                    if (value > 0) {
                        const x = 50 + ((a - 2) / (maxA - 2)) * (canvas.width - 100);
                        const y = canvas.height - 50 - ((b - 1) / (maxB - 1)) * (canvas.height - 100);
                        
                        // Color by value
                        const hue = (value % 360);
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Label value
                        if (value <= 100 || (a <= 10 && b <= 10)) {
                            ctx.fillStyle = 'white';
                            ctx.font = '9px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(value, x, y - 8);
                        }
                    }
                }
            }
        }
        
        function analyzeGaps() {
            const start = parseInt(document.getElementById('gapStart').value);
            const end = parseInt(document.getElementById('gapEnd').value);
            const depth = parseInt(document.getElementById('gapDepth').value);
            
            const {covered, uncovered} = computeCoverage(end, depth);
            const gapsInRange = uncovered.filter(n => n >= start && n <= end);
            
            // Draw gap visualization
            const canvas = document.getElementById('gapCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title
            ctx.fillStyle = '#00bcd4';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`Gap Analysis: Range ${start}-${end}`, 10, 25);
            
            // Number line
            const lineY = canvas.height / 2;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, lineY);
            ctx.lineTo(canvas.width - 50, lineY);
            ctx.stroke();
            
            // Plot gaps
            gapsInRange.forEach(n => {
                const x = 50 + ((n - start) / (end - start)) * (canvas.width - 100);
                
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(x, lineY, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw vertical line for visibility
                ctx.strokeStyle = 'rgba(255,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, lineY - 20);
                ctx.lineTo(x, lineY + 20);
                ctx.stroke();
            });
            
            // Statistics
            const resultsEl = document.getElementById('gapResults');
            resultsEl.innerHTML = `
                <div class="stat-grid">
                    <div class="stat-item">
                        <div class="stat-label">Range</div>
                        <div class="stat-value">${start} - ${end}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Uncovered Count</div>
                        <div class="stat-value">${gapsInRange.length}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Coverage Rate</div>
                        <div class="stat-value">${((end - start + 1 - gapsInRange.length) / (end - start + 1) * 100).toFixed(2)}%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Search Depth</div>
                        <div class="stat-value">a,b ≤ ${depth}</div>
                    </div>
                </div>
                <p style="margin-top: 20px;">First 20 uncovered: ${gapsInRange.slice(0, 20).join(', ')}</p>
            `;
        }
        
        function runStatistics() {
            const type = document.getElementById('analysisType').value;
            const param = parseInt(document.getElementById('analysisParam').value);
            
            const canvas = document.getElementById('statsCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const searchDepth = Math.ceil(Math.sqrt(param));
            
            if (type === 'density') {
                // Density function
                const windowSize = 50;
                const densities = [];
                
                for (let center = windowSize; center <= param; center += windowSize) {
                    const {covered} = computeCoverage(center + windowSize/2, Math.ceil(Math.sqrt(center + windowSize/2)));
                    let count = 0;
                    for (let n = center - windowSize/2; n <= center + windowSize/2; n++) {
                        if (covered.has(n)) count++;
                    }
                    densities.push({
                        x: center,
                        density: count / (windowSize + 1)
                    });
                }
                
                // Title
                ctx.fillStyle = '#00bcd4';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Coverage Density Function', 10, 25);
                
                // Axes
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(50, 50);
                ctx.lineTo(50, canvas.height - 50);
                ctx.lineTo(canvas.width - 50, canvas.height - 50);
                ctx.stroke();
                
                // Plot density
                ctx.strokeStyle = '#00bcd4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                densities.forEach((d, i) => {
                    const x = 50 + ((d.x - windowSize) / (param - windowSize)) * (canvas.width - 100);
                    const y = 50 + (1 - d.density) * (canvas.height - 100);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Points
                densities.forEach(d => {
                    const x = 50 + ((d.x - windowSize) / (param - windowSize)) * (canvas.width - 100);
                    const y = 50 + (1 - d.density) * (canvas.height - 100);
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                document.getElementById('statsResults').innerHTML = `
                    <p>Average density: ${(densities.reduce((s, d) => s + d.density, 0) / densities.length).toFixed(4)}</p>
                `;
                
            } else if (type === 'modular') {
                // Modular distribution
                const {covered} = computeCoverage(param, searchDepth);
                const modCounts = [0, 0, 0, 0, 0, 0];
                const modUncovered = [0, 0, 0, 0, 0, 0];
                
                for (let n = 1; n <= param; n++) {
                    const mod = n % 6;
                    modCounts[mod]++;
                    if (!covered.has(n)) {
                        modUncovered[mod]++;
                    }
                }
                
                // Title
                ctx.fillStyle = '#00bcd4';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Modular Distribution (mod 6)', 10, 25);
                
                // Bars
                const barWidth = (canvas.width - 100) / 6;
                const maxHeight = canvas.height - 150;
                
                for (let m = 0; m < 6; m++) {
                    const x = 50 + m * barWidth;
                    const coveredHeight = modCounts[m] > 0 ? 
                        ((modCounts[m] - modUncovered[m]) / modCounts[m]) * maxHeight : 0;
                    const uncoveredHeight = modCounts[m] > 0 ? 
                        (modUncovered[m] / modCounts[m]) * maxHeight : 0;
                    
                    // Covered (green)
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(x + barWidth * 0.1, canvas.height - 50 - coveredHeight, 
                                barWidth * 0.8, coveredHeight);
                    
                    // Uncovered (red) on top
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(x + barWidth * 0.1, canvas.height - 50 - coveredHeight - uncoveredHeight,
                                barWidth * 0.8, uncoveredHeight);
                    
                    // Labels
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`mod ${m}`, x + barWidth/2, canvas.height - 30);
                    
                    const pct = modCounts[m] > 0 ? (modUncovered[m]/modCounts[m]*100).toFixed(1) : '0';
                    ctx.fillText(`${pct}%`, x + barWidth/2, canvas.height - 60 - coveredHeight - uncoveredHeight);
                }
                
            } else if (type === 'growth') {
                // Growth rate
                const points = [];
                for (let n = 100; n <= param; n += 100) {
                    const {uncovered} = computeCoverage(n, Math.ceil(Math.sqrt(n)));
                    points.push({
                        n: n,
                        count: uncovered.length,
                        rate: uncovered.length / n
                    });
                }
                
                // Title
                ctx.fillStyle = '#00bcd4';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Uncovered Numbers Growth Rate', 10, 25);
                
                // Axes
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(50, 50);
                ctx.lineTo(50, canvas.height - 50);
                ctx.lineTo(canvas.width - 50, canvas.height - 50);
                ctx.stroke();
                
                // Plot growth
                ctx.strokeStyle = '#00bcd4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                points.forEach((p, i) => {
                    const x = 50 + (p.n / param) * (canvas.width - 100);
                    const y = 50 + (1 - p.rate * 5) * (canvas.height - 100); // Scale for visibility
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Points with labels
                points.forEach(p => {
                    const x = 50 + (p.n / param) * (canvas.width - 100);
                    const y = 50 + (1 - p.rate * 5) * (canvas.height - 100);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.count, x, y - 8);
                });
                
            } else if (type === 'range') {
                // Coverage by range
                const ranges = [];
                const step = Math.floor(param / 10);
                
                for (let start = 1; start <= param; start += step) {
                    const end = Math.min(start + step - 1, param);
                    const {covered} = computeCoverage(end, Math.ceil(Math.sqrt(end)));
                    
                    let coveredInRange = 0;
                    for (let n = start; n <= end; n++) {
                        if (covered.has(n)) coveredInRange++;
                    }
                    
                    const total = end - start + 1;
                    ranges.push({
                        start: start,
                        end: end,
                        rate: coveredInRange / total
                    });
                }
                
                // Title
                ctx.fillStyle = '#00bcd4';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Coverage by Range', 10, 25);
                
                // Bars
                const barWidth = (canvas.width - 100) / ranges.length;
                const maxHeight = canvas.height - 150;
                
                ranges.forEach((r, i) => {
                    const x = 50 + i * barWidth;
                    const height = r.rate * maxHeight;
                    
                    // Gradient bar
                    const gradient = ctx.createLinearGradient(0, canvas.height - 50 - height, 0, canvas.height - 50);
                    gradient.addColorStop(0, '#00bcd4');
                    gradient.addColorStop(1, '#006064');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x + barWidth * 0.1, canvas.height - 50 - height, barWidth * 0.8, height);
                    
                    // Percentage
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${(r.rate * 100).toFixed(1)}%`, x + barWidth/2, canvas.height - 55 - height);
                    
                    // Range label
                    ctx.save();
                    ctx.translate(x + barWidth/2, canvas.height - 30);
                    ctx.rotate(-Math.PI/4);
                    ctx.font = '9px Arial';
                    ctx.fillText(`${r.start}-${r.end}`, 0, 0);
                    ctx.restore();
                });
            }
        }
        
        function analyzePatterns() {
            const type = document.getElementById('patternType').value;
            const limit = parseInt(document.getElementById('patternLimit').value);
            const {uncovered} = computeCoverage(limit, Math.ceil(Math.sqrt(limit)));
            
            const canvas = document.getElementById('patternCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (type === 'arithmetic') {
                // Find arithmetic progressions
                const progressions = [];
                for (let i = 0; i < uncovered.length - 2; i++) {
                    const diff = uncovered[i + 1] - uncovered[i];
                    let length = 2;
                    let j = i + 1;
                    
                    while (j < uncovered.length - 1 && uncovered[j + 1] - uncovered[j] === diff) {
                        length++;
                        j++;
                    }
                    
                    if (length >= 3) {
                        progressions.push({
                            start: uncovered[i],
                            diff: diff,
                            length: length,
                            sequence: uncovered.slice(i, i + length)
                        });
                        i = j;
                    }
                }
                
                // Title
                ctx.fillStyle = '#00bcd4';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Arithmetic Progressions in Uncovered Numbers', 10, 25);
                
                // Number line
                const lineY = canvas.height / 2;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, lineY);
                ctx.lineTo(canvas.width - 50, lineY);
                ctx.stroke();
                
                // Plot progressions
                progressions.slice(0, 10).forEach((prog, idx) => {
                    const color = `hsl(${idx * 36}, 100%, 50%)`;
                    
                    prog.sequence.forEach(n => {
                        if (n <= 200) {
                            const x = 50 + (n / 200) * (canvas.width - 100);
                            
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(x, lineY, 5, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            ctx.fillStyle = 'white';
                            ctx.font = '9px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(n, x, lineY - 10);
                        }
                    });
                });
                
                document.getElementById('patternResults').innerHTML = `
                    <p>Found ${progressions.length} arithmetic progressions</p>
                    <p>First few: ${progressions.slice(0, 5).map(p => 
                        `[${p.sequence.join(', ')}]`).join(', ')}</p>
                `;
                
            } else if (type === 'prime') {
                // Prime analysis
                function isPrime(n) {
                    if (n < 2) return false;
                    for (let i = 2; i * i <= n; i++) {
                        if (n % i === 0) return false;
                    }
                    return true;
                }
                
                const primeUncovered = uncovered.filter(isPrime);
                const compositeUncovered = uncovered.filter(n => !isPrime(n) && n > 1);
                
                // Title
                ctx.fillStyle = '#00bcd4';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Prime vs Composite Uncovered Numbers', 10, 25);
                
                // Bars
                const barWidth = canvas.width / 3;
                const maxHeight = canvas.height - 100;
                
                // Prime bar
                const primeHeight = (primeUncovered.length / uncovered.length) * maxHeight;
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(barWidth * 0.5, canvas.height - 50 - primeHeight, barWidth * 0.8, primeHeight);
                
                // Composite bar
                const compositeHeight = (compositeUncovered.length / uncovered.length) * maxHeight;
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(barWidth * 1.5, canvas.height - 50 - compositeHeight, barWidth * 0.8, compositeHeight);
                
                // Labels
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Primes', barWidth * 0.9, canvas.height - 20);
                ctx.fillText(`${primeUncovered.length}`, barWidth * 0.9, canvas.height - 60 - primeHeight);
                
                ctx.fillText('Composites', barWidth * 1.9, canvas.height - 20);
                ctx.fillText(`${compositeUncovered.length}`, barWidth * 1.9, canvas.height - 60 - compositeHeight);
                
                document.getElementById('patternResults').innerHTML = `
                    <p>Prime uncovered: ${primeUncovered.length} (${(primeUncovered.length/uncovered.length*100).toFixed(1)}%)</p>
                    <p>First primes: ${primeUncovered.slice(0, 10).join(', ')}</p>
                `;
                
            } else if (type === 'twins') {
                // Twin pairs
                const twins = [];
                for (let i = 0; i < uncovered.length - 1; i++) {
                    if (uncovered[i + 1] - uncovered[i] === 2) {
                        twins.push([uncovered[i], uncovered[i + 1]]);
                    }
                }
                
                // Title
                ctx.fillStyle = '#00bcd4';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Twin Uncovered Pairs (difference = 2)', 10, 25);
                
                // Draw pairs
                const startY = 60;
                twins.slice(0, 12).forEach((pair, i) => {
                    const y = startY + i * 30;
                    
                    // Connect line
                    ctx.strokeStyle = '#00bcd4';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(100, y);
                    ctx.lineTo(200, y);
                    ctx.stroke();
                    
                    // Numbers
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(100, y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(200, y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(pair[0], 100, y + 4);
                    ctx.fillText(pair[1], 200, y + 4);
                });
                
                document.getElementById('patternResults').innerHTML = `
                    <p>Found ${twins.length} twin pairs</p>
                    <p>Pairs: ${twins.slice(0, 10).map(p => `(${p[0]}, ${p[1]})`).join(', ')}</p>
                `;
                
            } else if (type === 'clusters') {
                // Gap distribution
                const gaps = [];
                for (let i = 1; i < uncovered.length; i++) {
                    gaps.push(uncovered[i] - uncovered[i - 1]);
                }
                
                const gapCounts = {};
                gaps.forEach(g => {
                    gapCounts[g] = (gapCounts[g] || 0) + 1;
                });
                
                // Title
                ctx.fillStyle = '#00bcd4';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('Gap Distribution in Uncovered Numbers', 10, 25);
                
                // Histogram
                const maxGap = Math.min(20, Math.max(...Object.keys(gapCounts).map(Number)));
                const barWidth = (canvas.width - 100) / maxGap;
                const maxCount = Math.max(...Object.values(gapCounts));
                const maxHeight = canvas.height - 100;
                
                for (let gap = 1; gap <= maxGap; gap++) {
                    const count = gapCounts[gap] || 0;
                    const height = (count / maxCount) * maxHeight;
                    const x = 50 + (gap - 1) * barWidth;
                    
                    ctx.fillStyle = `hsl(${180 - gap * 8}, 100%, 50%)`;
                    ctx.fillRect(x, canvas.height - 50 - height, barWidth * 0.8, height);
                    
                    if (count > 0) {
                        ctx.fillStyle = 'white';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(count, x + barWidth * 0.4, canvas.height - 55 - height);
                    }
                    
                    ctx.fillText(gap, x + barWidth * 0.4, canvas.height - 30);
                }
                
                const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
                document.getElementById('patternResults').innerHTML = `
                    <p>Average gap: ${avgGap.toFixed(2)}</p>
                    <p>Most common gap: ${Object.entries(gapCounts).reduce((a, b) => b[1] > a[1] ? b : a)[0]}</p>
                `;
            }
        }
        
        function exploreFormula() {
            const n = parseInt(document.getElementById('testNumber').value);
            const maxSearch = parseInt(document.getElementById('formulaMax').value);
            
            const canvas = document.getElementById('formulaCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Find representations
            const solutions = [];
            for (let a = 1; a <= maxSearch; a++) {
                for (let b = 1; b <= maxSearch; b++) {
                    if (6*a*b + a + b === n) solutions.push({a, b, form: '++'});
                    if (6*a*b + a - b === n) solutions.push({a, b, form: '+-'});
                    if (6*a*b - a + b === n) solutions.push({a, b, form: '-+'});
                    if (6*a*b - a - b === n) solutions.push({a, b, form: '--'});
                }
            }
            
            // Title
            ctx.fillStyle = '#00bcd4';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`Decomposition Explorer for n = ${n}`, 10, 25);
            
            if (solutions.length === 0) {
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${n} is UNCOVERED`, canvas.width/2, canvas.height/2);
            } else {
                // Coordinate plot
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(50, 50);
                ctx.lineTo(50, canvas.height - 50);
                ctx.lineTo(canvas.width - 50, canvas.height - 50);
                ctx.stroke();
                
                // Plot solutions
                const colors = {'++': '#00ff00', '+-': '#ff00ff', '-+': '#ffff00', '--': '#ff0000'};
                
                solutions.forEach(sol => {
                    const x = 50 + (sol.a / maxSearch) * (canvas.width - 100);
                    const y = canvas.height - 50 - (sol.b / maxSearch) * (canvas.height - 100);
                    
                    ctx.fillStyle = colors[sol.form];
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`(${sol.a},${sol.b})`, x + 8, y);
                });
                
                // Legend
                Object.entries(colors).forEach(([form, color], i) => {
                    ctx.fillStyle = color;
                    ctx.fillRect(canvas.width - 150, 60 + i * 25, 15, 15);
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText(form === '++' ? '6ab + a + b' :
                                form === '+-' ? '6ab + a - b' :
                                form === '-+' ? '6ab - a + b' : '6ab - a - b',
                                canvas.width - 130, 72 + i * 25);
                });
            }
            
            document.getElementById('formulaResults').innerHTML = solutions.length === 0 ?
                `<p style="color: #ff0000;">n = ${n} is UNCOVERED</p>` :
                `<p style="color: #00ff00;">n = ${n} has ${solutions.length} representations</p>
                 <p>${solutions.map(s => `(${s.a}, ${s.b}) via form ${s.form}`).join('<br>')}</p>`;
        }
        
        function render3D() {
            const canvas = document.getElementById('canvas3d');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const form = document.getElementById('form3d').value;
            const maxA = parseInt(document.getElementById('maxA3d').value);
            const maxB = parseInt(document.getElementById('maxB3d').value);
            
            // Update display
            document.getElementById('maxA3dValue').textContent = maxA;
            document.getElementById('maxB3dValue').textContent = maxB;
            
            // Title
            ctx.fillStyle = '#00bcd4';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`3D Lattice Visualization: ${form === 'all' ? 'All Forms' : 'Form ' + form}`, 10, 25);
            
            // Simple 3D projection
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 8;
            
            for (let a = 2; a <= maxA; a += 2) {
                for (let b = 1; b <= maxB; b++) {
                    const forms = form === 'all' ? 
                        ['++', '+-', '-+', '--'] : [form];
                    
                    forms.forEach(f => {
                        let val;
                        if (f === '++') val = 6*a*b + a + b;
                        else if (f === '+-') val = 6*a*b + a - b;
                        else if (f === '-+') val = 6*a*b - a + b;
                        else val = 6*a*b - a - b;
                        
                        if (val > 0) {
                            // Simple 3D to 2D projection
                            const x = centerX + (a - maxA/2) * scale - (b - maxB/2) * scale;
                            const y = centerY + (b - maxB/2) * scale + (val/100 - 5) * 2;
                            
                            const colors = {'++': '#00ff00', '+-': '#ff00ff', '-+': '#ffff00', '--': '#ff0000'};
                            ctx.fillStyle = colors[f];
                            ctx.globalAlpha = 0.7;
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    });
                }
            }
        }
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            // Initialize tab if needed
            if (tabName === 'coverage') updateCoverage();
            else if (tabName === 'lattice') updateLattice();
            else if (tabName === 'gaps') analyzeGaps();
            else if (tabName === 'statistics') runStatistics();
            else if (tabName === 'patterns') analyzePatterns();
            else if (tabName === 'formulas') exploreFormula();
            else if (tabName === 'visualization3d') render3D();
        }
        
        function exportData() {
            const maxN = parseInt(document.getElementById('maxN').value);
            const maxAB = parseInt(document.getElementById('maxAB').value);
            const {covered, uncovered, representations} = computeCoverage(maxN, maxAB);
            
            const data = {
                parameters: {maxN, maxAB, sqrtOptimized: document.getElementById('sqrtLock')?.checked},
                statistics: {
                    covered: covered.size,
                    uncovered: uncovered.length,
                    coverageRate: (covered.size / maxN * 100).toFixed(2) + '%'
                },
                uncoveredNumbers: uncovered,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const link = document.createElement('a');
            link.download = `sierpinski-data-${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function exportReport() {
            window.print();
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', function() {
            applySqrtLock();
            applySqrtLockGaps();
            
            // Add slider listeners
            document.getElementById('maxA3d')?.addEventListener('input', function() {
                document.getElementById('maxA3dValue').textContent = this.value;
            });
            document.getElementById('maxB3d')?.addEventListener('input', function() {
                document.getElementById('maxB3dValue').textContent = this.value;
            });
        });
    </script>
</body>
</html>
